package main

import (
	"fmt"
	"net"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/go-git/go-billy/v5/memfs"
	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/storage/memory"
)

const REPO = "test.git" // generated by setup.sh

func main() {
	var (
		url string
		err error
		c   = make(chan os.Signal, 1)
	)

	// Serve git repo via HTTP, returning full URL
	if url, err = serve(REPO); err != nil {
		fmt.Fprintf(os.Stderr, "failed to expose git repo via HTTP: %v", err)
		os.Exit(1)
	}

	// Clone the repo into memory
	if err = clone(url); err != nil {
		fmt.Fprintf(os.Stderr, "failed to clone: %v\n", err)
	}

	// Wait for interrupts before exiting
	fmt.Printf("%v available at %v\n", REPO, url)
	signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
	<-c
}

func serve(path string) (url string, err error) {
	// Begin listening at an os-chosen port
	listener, err := net.Listen("tcp", "127.0.0.1:")
	if err != nil {
		return
	}

	// Serve the REPO directory using basic HTTP
	s := &http.Server{
		Handler:        http.FileServer(http.Dir(path)),
		ReadTimeout:    10 * time.Second,
		WriteTimeout:   10 * time.Second,
		MaxHeaderBytes: 1 << 20,
	}
	go func() {
		s.Serve(listener)
	}()

	// Return the URL at which the repo can be cloned
	url = "http://" + listener.Addr().String()
	return
}

// Clone REPO into memory using the go-git library and
// confirm that the README.md was pulled.
func clone(url string) error {
	r, err := git.Clone(
		memory.NewStorage(),
		memfs.New(),
		&git.CloneOptions{
			URL:               url,
			Depth:             1,
			Tags:              git.NoTags,
			RecurseSubmodules: git.NoRecurseSubmodules,
		})
	if err != nil {
		return err
	}
	wt, err := r.Worktree()
	if err != nil {
		return err
	}
	fs := wt.Filesystem
	if _, err := fs.Stat("README.md"); err != nil {
		return fmt.Errorf("README.md not found in in-memory cloned %v from %v: %v", REPO, url, err)
	}
	return nil
}
